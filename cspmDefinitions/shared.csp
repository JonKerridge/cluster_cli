N = 3

datatype objects = A.{1..N} | B.{1..N} | UT

subtype Aobj = A.{1..N} | UT
subtype Bobj = B.{1..N} | UT

channel aChan: Aobj
channel bChan: Bobj
channel sharedOut: objects
channel finished: Bool
--channel all: objects

-- event alphabets
a_aChan = {|aChan|}
a_bChan = {|bChan|}
a_all = {|aChan, bChan|}
a_sharedOut = {|sharedOut|}

gen(A.i) = if i == N then UT else A.(i+1)
gen(B.i) = if i == N then UT else B.(i+1)

EmitA(o) = aChan!o -> if o == UT then SKIP else EmitA(gen(o))

EmitB(o) = bChan!o -> if o == UT then SKIP else EmitB(gen(o))

Emitter() = EmitA(A.1) ||| EmitB(B.1)

result = <A.1, A.2, A.3, B.1, B.2, B.3>

Shared() = aChan?o -> if o == UT then SharedEndB()
                       else sharedOut!o -> Shared()
            []
            bChan?o -> if o == UT then SharedEndA()
                       else sharedOut!o -> Shared()

SharedEndA() = aChan?o -> sharedOut!o -> if o == UT then SKIP
                                            else SharedEndA() 
                                
SharedEndB() = bChan?o -> sharedOut!o -> if o == UT then SKIP
                                            else SharedEndB() 
 
Collect() = sharedOut?o -> if o == UT then Collect_End() 
                              else  if elem(o, result) then Collect() 
                                       else STOP  

Collect_End() = finished!True -> Collect_End()

TestSystem = finished!True -> TestSystem   --the model used for testing

System = (Emitter() [|a_all|] Shared()) [|a_sharedOut|] Collect()

assert (System \ {|aChan, bChan, sharedOut|}) [T= TestSystem
assert (System \ {|aChan, bChan, sharedOut|}) [F= TestSystem
assert (System \ {|aChan, bChan, sharedOut|}) [FD= TestSystem

assert System :[deadlock free]
assert System :[divergence free]
assert System :[deterministic]
                        